/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. RelationalAlgebra.jj */
/*@egen*//**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(RATree)package ratree;

public class RATree/*@bgen(jjtree)*/implements RATreeTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTRATreeState jjtree = new JJTRATreeState();

/*@egen*/  public static void main(String args [])  {    System.out.println("Please input a relational algebra expression: ");
    RATree ra = new RATree(System.in);
    try
    {
      SimpleNode n = ra.Start();
      n.dump("");
      System.out.println("Thank you.");
    }
    catch(ParseException e)
    {
      System.out.println("THE INPUT IS NOT A RELATIONAL ALGEBRA EXPRESSION!");
      System.out.println(e.getMessage());
    }
    catch(TokenMgrError e)
    {
      System.out.println("UNRECOGNISABLE TOKEN!");
      System.out.println(e.getMessage());
    }
  }}PARSER_END(RATree)SKIP :{  " "| "\t"| "\n"| "\r"}TOKEN : /* LITERALS */{  < PROJECT : "\u03c0" >
| < SELECT : "\u03c3" >
| < UNION : "\u222a" >
| < INTERSECT : "\u2229" >
| < RENAME : "\u03c1" >
| < JOIN : "\u22c8" >
| < CARTESIAN : "\u00d7" >
| < DIFFERENCE : "-" >
| < ASSIGN : "\u2190" >
| < COMPARE : ("<" | ">" | "!=" | "=" | "<=" | ">=") >
| < AND : "\u039b" >
| < OR : "\u2228" >}TOKEN : /* IDENTIFIERS */{  < NUMBER : (< DIGIT >)+ >
| < WORD : (< LETTER >)+ >
| < CONSTRAIN : "'"(~["'"])+"'" >
| < #DIGIT : [ "0"-"9" ] >
| < #LETTER : ["a"-"z", "A"-"Z"] >}

/**
* The JavaCC grammar for Relational Algebra expressions
* Used to generate a JavaCC parse tree.
*/SimpleNode Start() :{/*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Start */
  try {
/*@egen*/  expression() ";"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

int one_line() :
{/*@bgen(jjtree) one_line */
  SimpleNode jjtn000 = new SimpleNode(JJTONE_LINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) one_line */
  try {
/*@egen*/
  expression()";"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return 0;
  }
| ";"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return 1;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
// the relational algebra expressions
// they can be just relations, or projection, selection, set, rename or assignment expressionsString expression()      :{/*@bgen(jjtree) EXPR */
 SimpleNode jjtn000 = new SimpleNode(JJTEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String s; String expr = "";}{/*@bgen(jjtree) EXPR */
try {
/*@egen*/
(
  expr = relation()
  (
    assignexpr()  )?
| expr = projectexpr()
| expr = selectexpr()
| expr = renameexpr()
| expr = assignexpr()
)
{jjtn000.value = expr;}
// the expression can be followed by zero or more expressions combined by set operators
  (
    LOOKAHEAD(2)
    s = setop() { expr += s; }
    s = expression() { expr += s; }
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return expr;  }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/}

// assignment expressions. Assign the result of a relational algebra to another name
String assignexpr()        :
{/*@bgen(jjtree) ASSIGN */
 SimpleNode jjtn000 = new SimpleNode(JJTASSIGN);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String s; String assign = "";}{/*@bgen(jjtree) ASSIGN */
  try {
/*@egen*/
  t = < ASSIGN > { assign += t.image.toString(); }
  s = expression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { assign += s; jjtn000.value = assign; return assign; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// the operators for the set expressions
String setop()       :
{/*@bgen(jjtree) SETOP */
 SimpleNode jjtn000 = new SimpleNode(JJTSETOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String s; String set = "";}{/*@bgen(jjtree) SETOP */
  try {
/*@egen*/
  (
      t = < JOIN >  { set += t.image.toString(); }
      (        "{"s = conditions()"}" { set += "{" + s + "}"; }
      )?
    | t = < CARTESIAN > { set += t.image.toString(); }
    | t = < DIFFERENCE > { set += t.image.toString(); }
    | t = < UNION > { set += t.image.toString(); }
    | t = < INTERSECT > { set += t.image.toString(); }
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = set; return set; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// rename expression. Rename a relation, projection or selection expression
String renameexpr()        :
{/*@bgen(jjtree) RENAME */
 SimpleNode jjtn000 = new SimpleNode(JJTRENAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String s; String rename = "";}{/*@bgen(jjtree) RENAME */
  try {
/*@egen*/
  t = < RENAME > { rename += t.image.toString(); }
  t = < WORD >  { rename += t.image.toString(); }
  "("s = expression()")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { rename += "(" + s + ")"; jjtn000.value = rename; return rename; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// selection expression
String selectexpr()     :
{/*@bgen(jjtree) SEL */
 SimpleNode jjtn000 = new SimpleNode(JJTSEL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String s; String sel = "";}
{/*@bgen(jjtree) SEL */
  try {
/*@egen*/
  t = < SELECT > { sel += t.image.toString(); }
  s = conditions() { sel += s; }
  "("s = expression()")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { sel += "(" + s + ")"; jjtn000.value = sel; return sel; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// project expression
String projectexpr()      :
{/*@bgen(jjtree) PROJ */
 SimpleNode jjtn000 = new SimpleNode(JJTPROJ);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String s; String proj = "";}{/*@bgen(jjtree) PROJ */
  try {
/*@egen*/
  t = < PROJECT > { proj += t.image.toString(); }
  s = attributelist() { proj += s; }
  "("s = expression()")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { proj += "(" + s + ")"; jjtn000.value = proj; return proj; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// the relations
String relation()      :
{/*@bgen(jjtree) RELA */
 SimpleNode jjtn000 = new SimpleNode(JJTRELA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String s; String rela = "";}
{/*@bgen(jjtree) RELA */
  try {
/*@egen*/
  t = < WORD > { rela += t.image.toString(); }
  (t = < NUMBER > { rela += t.image.toString(); })*
  (t = < WORD > { rela += t.image.toString(); })*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = rela; return rela; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// the attributes
String attribute()      :
{/*@bgen(jjtree) ATTR */
 SimpleNode jjtn000 = new SimpleNode(JJTATTR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String s = "";}
{/*@bgen(jjtree) ATTR */
try {
/*@egen*/
(    t = < WORD >{ s += t.image.toString(); }     
    (t = < NUMBER > { s += t.image.toString(); })*
    (t = < WORD > { s += t.image.toString(); })*
  (
    "."t = < WORD >{ s += "." + t.image.toString(); }
    (t = < NUMBER > { s += t.image.toString(); })*
    (t = < WORD > { s += t.image.toString(); })*
  )?
)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = s; return s; }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// a list of attributes, used in projectiong expressions
String attributelist()          :
{/*@bgen(jjtree) ATTRLIST */
 SimpleNode jjtn000 = new SimpleNode(JJTATTRLIST);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String s; String attrlist = "";}{/*@bgen(jjtree) ATTRLIST */
  try {
/*@egen*/
  s = attribute() { attrlist += s; }
  (
    "," { attrlist += ","; }
    s = attribute() { attrlist += s; }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = attrlist; return attrlist; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// operands used in conditions
String operand()      :
{/*@bgen(jjtree) OPER */
  SimpleNode jjtn000 = new SimpleNode(JJTOPER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String s = ""; }
{/*@bgen(jjtree) OPER */
  try {
/*@egen*/
  (    s = attribute()
  | t = < CONSTRAIN > { s += t.image.toString(); }
  | t = < NUMBER > { s += t.image.toString(); }
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = s; return s; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// one simple condition used in the conditions
String condition()      :
{/*@bgen(jjtree) COND */
 SimpleNode jjtn000 = new SimpleNode(JJTCOND);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String s; String cond = "";}
{/*@bgen(jjtree) COND */
  try {
/*@egen*/
  cond = operand()
  t = < COMPARE > { cond += t.image.toString(); }
  s = operand()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { cond += s; jjtn000.value = cond; return cond; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// a list of simple conditions used in selection expression
String conditions()       :
{/*@bgen(jjtree) CONDS */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String s; String conds = ""; }{/*@bgen(jjtree) CONDS */
  try {
/*@egen*/
  s = condition() {conds += s;}
 (
  s = andor() {conds += s;}
  s = condition() {conds += s;}
 )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {jjtn000.value = conds; return conds;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

// AND or OR operands connect the conditions
String andor()       :
{/*@bgen(jjtree) ANDOR */
 SimpleNode jjtn000 = new SimpleNode(JJTANDOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String andor = "";}{/*@bgen(jjtree) ANDOR */
  try {
/*@egen*/
  (    t = < AND >      
  | t = < OR >
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {andor = t.image.toString(); jjtn000.value = andor; return andor;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
